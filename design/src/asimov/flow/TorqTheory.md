# Torq Theory, Torq Mining, and The Equation of AI-Value Exchange

All those things in the title are so inextricably intertwined that they must be defined in the same place. Get ready for a whopper of a design doc.

The Torq Mining Flow Loop is where production happens and value is created.

But how much value is created? And we have to tie in the value being added not just by the robot, but by the AI driving the robot!

By the end of this document, you'll discover the direct links between system AI energy consumption and token throughput, aka capacity, how much of that capacity goes to a given Robot, how much of it the robot actually uses, the exact amount of Torq generated by that production, how that Torq scales to market value, and when exactly that value gets transferred to Isaac for minting.

You'll also finally understand what TokenTorq is.

This is the direct mathematical tie between AI tokens and minting, calculus and all, that makes Robonomic Torq Theory a revolutionary theory of economics.

## Let's start out with our definitions

token_torq_potential: How much compute Giskard can manage to give, and at what cost 
- if it works at maximum thermodynamic efficiency (never happens)
- relative to the total compute consumption of the Bond Network, 
- TokenTorq is measured in RoboTorq/token/kW =  RoboTorq / (token * kW)
- TokenTorq (get it now?) is the cost paid to Isaac for processing energized tokens through Giskard

Energized tokens are tokens that are causing real physical work to happen via a robot, as opposed to when you ask an AI a question and it gives you useful information. So Giskard and Isaac care about:
- token throughput, 
- and how much energy is attached to processing that token throughput due to AIntropy (pronounced "ane-tropy," entropy was already taken)
- and how much RoboTorq it's costing him to make it happen.

Let's take a second to discuss AIntropy as a variable: -0.1 <= AIntropy <= 0.1 (could have slightly higher amplitude)
- for tuning the convergence of the productivity curve.
- Units are (token * kWh), so it's always implied at 
- Negative values of AIntropy are for Oracles with only one task/item/product where the Torq gains are diminishing as the Oracle is closer to being fulfilled
- Positive values are for Oracles with multiple items, where the Torq gains will increase with each product produced.

He cares about this because he has 
- `Giskard.token_torq_potential = (Giskard.max_token_throughput * Giskard.max_energy_consumption) / Giskard.tick_operating_cost`
- and gives to robots at some TokenTorkDrain.tick_rate assigned to the drain by Giskard

TokenTorqDrain.tick_rate = This is a rate-limited measure of AI energy potential: how much of the system's resources are available to devote to each robot's tokens on average?
	- Another way to think of it: More complex tasks, or more important ones (as Giskard sees it), like welding starship components for Network Upgrades, will get more token_torq_potential, while a robot running a banana stand might not get as much.
- can be grabbed at any given time:
- `TokenTorqDrain.tick_rate = -token_torq_potential`,
- negative by convention to represent TokenTorq leaving the {Robot, Product} system.
- may or may not vary from tick to tick, depending on Giskard's other responsibilities.
- The token_torq_potential_range data set is provided by Giskard when an Enterprise is forming its bid.

Because Giskard has more than one robot to worry about, a maximum and a minimum TokenTorqDrain.tick_rate are guaranteed for every BRLA. An average is not guaranteed. This allows several advantages:
 - gives Giskard wiggle room for other needs.
- gives the Enterprise wiggle room on timeline, supply chain disruptions, final price, etc
- gives Daneel wiggle room on scheduling and robot allocation, allowing for load rebalancing
- Allows for forecasting considering all these factors.

Example, BRLAs that can tolerate high variance in TokenTorqDrain.tick_rate, because they have learned how to master their learning curves and production timelines, will get better prices on BRLAs for being lower on the priority list for a steady rate.

token_productivity_curve: This learning curve is how quickly a robot gets better at a given task as a function of time.
- This is a measure of productivity in TokenTorkUsed/tick/TokenTorkPotential = 1/tick units
- Think of this like "how good is the robot at crafting the prompts it sends to its AI each tick?"
	- The robot has to learn how to prompt each task efficiently as it's doing it, as the operating conditions are always slightly different for every Oracle.
- At the beginning, the robot is sending bad prompts, but over time, the AI adds more and more value by using tokens more efficiently.
	- This means the robot gets more efficient with time, to a degree, it levels off after the robot gets as good as it can at that task.
- The learning curve of a robot working at 100% utilization is reasonably modeled using a basic Sigmoid Neural Net Activation Time function.

Remember, AIntropy is the throughput of energized tokens, it'll come into play here.
`token_productivity_curve = -(1/(1+e^(-ticks * AIntropy)))`, where ticks > 0 and 0.0 <= token_learning_curve < 1, and target_torq is the maximum desired torq
- token_productivity_curve is negative by convention, to represent TokenTorq and RoboTorq leaving the {Enterprise, Robot} system.
- In practice, this formula must be modified because no robot will ever function at 100% utilization:
	- Example modificaiton:
	- `expected_token_productivity_curve = -(1/(1+e^(-ticks Robot.util * target_torq * AIntropy)))`, 
	- and target torq scales the maximum value added
  	- Enterprises can either conduct studies to learn what their token_productivity_curve might look like, or roll the dice with mathematical modeling.
	- They can have a token_productivity_curve (production plan) for times of high availability and low
	- token_mining_curve is fully integrable and fully differentiable for all values of ticks < 0

Ideal torq_mining_curve: How much Torq is generated as a function of time?
- Is the mathematical integral of token_productivity_curve 
- Unitless: tick/tick = no units
- For a robot working at 100% utilization:
	- `torq_mining_curve = integral(token_productivity_curve)
	- `torq_mining_curve = -(ln(1+e^ticks) + ticks) 
- As TokenTorq and RoboTorq leave the {Enterprise, Robot} system, value is added to the {Bondholder, Product} system.
- Torq accumulates each tick as TokenTorq is mined into value.
- Eventually, the Oracle will be done, and the final Torq will be calculated and divided by the number of items produced.

The BRLA will wrap up the up Oracle and send the MintRequest to Isaac with a payload of the total Torq accumulated and Oracle.cost. So how will Isaac know how much to mint?

# The Equation of AI-Value Exchange: ProductionCost * Markup = ProductionCost * Torq

Easy enough... Except we need RoboTorqPaid as the cost of Production. Remember how we said that TokenTorkPotential's units are RoboTorq / Aintropy?

The Aintropy used is known from production. So RoboTorqPaid = TokenTorkPotential * Aintropy.

So RoboTorqOut as a function of time: RoboTorq = TokenTorkPotential * Aintropy * Torq

So let's say we had an Oracle run with 
- TokenTorkPotential=1/100,000 * Aintropy=(10,000 tokens * 10 kWh) * 1.7 Torq * 10 RoboTorqPaid = 17 RoboTorqOut in total value.

So Isaac will mint 17 - 10 = 7 RoboTorq to account for the markup, and distribute it to bondholders. 

He'll use the 10 RoboTorq to pay for the costs of running the Bond Network, and that will go back into circulation.

The Money Supply is in balance.

This ties the cost of AI consumption to the value created by robotic labor. The company is paying Isaac for however many (token * kWh) it used during actual production.

# Revision Stopping Point: Don't trust info below here

The lazy Enterprise, and maybe smarter, will modify their torq_mining_curve instead of token_mining_curve, because
	- the calculus is atrocious for complex learning curves, with ambiguous payoff, because
	- This form is easy to work with, and by the rules of calculus, you're modifying the learning curve whether you want to or not.
	- but cleans up, at least close enough for practical use. 
	- Let utc = Robot.util * target_torq * AIntropy
	- `Torq_mining_curve = utc * -(ln(1+e^(ticks * utc)) -  utc * ticks)`

But, this is all assuming things go perfectly. Real life is messy.

## Just like today, sometimes Enterprises have to guess how much they can sell something for at market

- torq_gamble: How much value does the company think it can add?
	- unitless scalar
 	- From a standard economics perspective, torq_gamble is the same thing as markup = selling price / production cost
  	- markup is also a unitless scalar, so in order to profit, torq_gamble has to be greater than the entire cost of production:
	- `torq_gamble > (brla_retainer_fee / (Oracle.robot_pool_size * item_count) + Oracle.cost + other production costs + overhead)
	- In robonomics, Isaac will mint exactly expected_selling_price = actual_torq_wielded * Oracle.cost - Oracle.cost
 - But they also have to take into account how many ticks it will take to generate that much raw Torq.
- Robot.util: How efficiently is a robot being utilized?
	- a unitless percentage.
 	- can be calculated/estimated by multiplying the individual efficiencies of the process
  	- `efficiencies = energy_efficiency * supply_efficiency * x_efficiency * y_efficiency ...`
  	- can and will vary from tick to tick.

- actual_torq_wielded: How much of token_torq_available is a robot using as a percentage?
	- can be calculated by multiplying:
 	- token_torq_wielded = token_torq_potential



  - based on Enterprise.torq_gamble. 
	- Intriguing, right? Patience.
- Torq: A unitless scalar achieved by integrating torq_factor, or by multiplying token_torq_consumed * torq_factor (kWh/token * tokens/kWh = no units) 

And picking up [where we left off in TokenTorqTrainingLoop.md](https://github.com/GrokkingGrok/Project-Asimov/blob/MVP/design/src/asimov/flow/TokenTorqTrainingLoop.md):
- Every TorqFountain.tick():
  - The Robot mines its TokenTorq into Torq with varying efficiency (representing production taking place).
    - The more efficiently it mines TokenTorq, the faster Robot.torq increases.
  - Several factors influence TokenTorq --> Torq conversion.
    - The more a robot has done the same task, the more efficiently it mines TokenTorq.
    - The type of task also influences how Torq is mined.
      - Complex tasks draw TokenTorq from Giskard at a higher rate, but mine slowly when production starts, and then produce lots of torq by the end.
      - Simple tasks draw less TokenTorq, but have flatter Torq curves.
    - The lower Giskard.tick_rate, the harder the robot has to work to mine Torq, the more Torq it produces per unit TokenTorq, but less Torq overall.

And then we hammered out the implications of TokenTorq --> Torq conversion: How it affects [Robonomic Expansion, Calvin, and the rest of the system](https://github.com/GrokkingGrok/Project-Asimov/blob/MVP/design/src/RobonomicExpansion.md).

Let's break down the Torq itself.



## Wrench in the Works

In order to calculate Torq during production, we need to know what torq_factor is because as mentioned in the intro: 

	- `Torq = TokenTorqConsumed * torq_factor * Daneel.expected_util`

But we can't know what torq_factor is until we know what torq_gamble is. We'll call it target_torq_factor for now since it's the torq_factor the Enterprise *hopes* to achieve:

`target_torq_factor = (1/(1+e^(-ticks)) - 0.5) / torq_gamble`

Well, you probably don't understand where that just came from. But that's ok, all you need to know for now is that it's a Sigmoid machine learning function, we're using it track time, and that you need torq_gamble to calculate target_torq_factor. 

torq_gamble is a value agreed upon by the Enterprise and BidNet at the time of accepting the Bid for this BRLA.

It represents the value added due to production. It is how the Enterprise makes its wager on the retail price it will sell the item for, hedged by how long they think it will take to make that item or items.

An Enterprise looking to submit their Bid might calculate their torq_gamble as such:

- `torq_gamble = (brla_retainer_fee / (Oracle.robot_pool_size * item_count) + Oracle.cost + other production costs + overhead) * markup 

The Enterprise is using the torq_gamble to bet on the **final realized retail price of the Oracle**. 

But here's how Bidnet will be looking at it.

## Ideal torq_factor Calculation

For reasons not relevant to this discussion, ideal_torq for a given task would be the mathematical integral of torq_factor.

If the general sigmoid form is:  `sigmoid = 1 / (1 + e^-x)`, the general form of the sigmoid integral is: `ln(1*e^(x)) + C`

Adapting that to our form, we get: 

	- `ideal_torq = (ln(1 + e^(ticks)) - .5* ticks - ln2) * torq_gamble +- fudge_factor`

If you solve the integral for how much continuous time it will take for actual_torq_mined to equal torq_gamble, you'll arrive at the ideal_tick_count. That is how quickly Giskard will expect this Oracle type to be produced, on average.

This means that Enterprises are not just bidding on how much they'll pay for the job, but also bidding on how long they think it'll take.

If the company takes too long, they'll overtorq. Too short, they'll undertorq. When the company doesn't have the sale planned in advance, it's wise to mass-produce many items under one Oracle, spreading the risk of over or under torqing across many sales.

Now that we have torq_factor and torq_gamble, we can calculate torq_mined... Once we have a formula for it, at least.



So that's how we calculate Torq. 

Now I know what you might thinking: "But, that means that companies get to ask for how much money they want to be created!" Well, yeah.

And what exactly do you think happens when a business (or you) takes out a loan now?

## But why wouldn't Enterprises just bid for one torq_gamble/timeline, and price for another?

Of course! I hadn't thought of that... Except, come to think of it, what exactly would they gain from such a thing, and how exactly would they do it?

While we haven't quite got there yet, the cost of a BRLA isn't a function of the torq_factor. Sure, it's considered, but it's more of a negotiating point than a function.

And think about what it *really* means... Like we discussed, the torq_factor is going to largely determine how much actual RoboTorq is minted.

**This is the money that the Enterprise's customers need minted for there to be enough RoboTorq to go around, without disturbing the overall money supply.**

Really, we should be more worried about companies bidding high and pricing low so that there is more RoboTorq to chase their goods, making it easier to sell. If Isaac undermints, there will be too few RoboTorq to chase the Enterprise's goods.

So they're not going to be unduly penalized in terms of the cost of a given BRLA. At least, not during that BRLA. But the system will be keeping track.

If an Enterprise is either bad at estimating torq_factor, or they are insistent on trying to game their torq_factor in some way, they'll face much stiffer negotiating tactics at BidNet, and their RoboFund Funnels will alert bondholders. Repeated infractions could result in being kicked off RoboFund, being required to rely on more expensive financing from TorqVaults.

So it's that Enterprise's ability to scheme against a network of AI financial overlords. Should be interesting.

What would be most interesting is if they're both meta-aware of their Nash equilibrium and prisoner's dilemma: Realize that they're making a co-wager on the success of this project, and cooperate to achieve a mutually better outcome.

## Tying Torq into... Quantum Game Theory?

Interestingly, the state Enterprise and Bidnet (and by extension, the customer who buys the product) could be modeled using set superpositioning, like those used in quantum computing algorithms. I wonder where that might lead?

Some wild places. That's where. Metaphorically, when looking at the system from the outside, torq_gamble "entangles" the two. How?

Well, it's impossible to know what the price of the item is going to be until the sale is made. So, like a qubit, measuring the probability cloud collapses the wave function.

This leads to the ability for BidNet to ask Calvin to run Game Theory forecasts from past data when negotiating BRLAs.















