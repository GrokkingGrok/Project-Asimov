# The Derivation of The RoboTorq from Physical Units

`1 RoboTorq / 1 RoboHour = 1 token * 1kW`, 
- because one thermodynamicaly perfect 1 kW Robot working for 1 hour processes 1 token with 1 Joule of energy every 1 second for 1 hour, and by definition would earn should earn 1 RoboTorq.

`1 RoboTorq = 1 token * 1KW * 1 RoboHour`, 
- from combining kW and hour to kWh.

`1 kW * 1 RoboHour = 3.6 million RoboJoules`, 
- because RoboJoules is the robotic equivalent of "manpower."

`1 RoboTorq = 1 token * 3.6 million RoboJoules`, 
- because RoboJoules provide context for how the Joules (energy) are being used (by a robot).

`1 micro TokenTorq = 1 token * 1 RoboJoule` 
- The TokenTorq is a novel unit definition: the AI/Robotic equivalent of physical torque.
- Not metaphorical. 
- It is how the information in a token is leveraged into value by roboticized energy.

`1 RoboTorq = 3.6 TokenTorq = 3.6 (token * kWh)`
- This is the value basis for the RoboTorq. It will never change so long as the laws of physics don't.

Likewise, `1 TokenTorq = 1/3.6 RoboTorq = 0.277778 RoboTorq`

That is the natural derivation of the value of 1 RoboTorq: 
- The value produced by 1 "thermodynamically perfect Robot" processing 1 token with 1 Joule of energy every 1 second for 1 hour.

The RoboTorq isn't technically backed by a commodity like the Gold Standard, though we can treat it similarly. 

The RoboTorq is backed by the laws of physics themselves, and it's the first currency in history to be so.

And this is the design doc where I'll prove it to you. Get ready for a whopper.

# The TorqMining Loop

The Torq Mining Flow Loop is where production happens and value is created.

But how much value is created? And we have to tie in the value being added not just by the robot, but by the AI driving the robot!

By the end of this document, you'll discover the direct links between system AI energy consumption and token throughput, aka capacity, how much of that capacity goes to a given Robot, how much of it the robot actually uses, the exact amount of Torq generated by that production, how that Torq scales to market value, and when exactly that value gets transferred to Isaac for minting.

Torq Theory is the direct mathematical tie between AI tokens and minting, calculus and all, that makes Robonomics a revolutionary theory of economics.

## Let's start out with our definitions

TokenTorqPotential: A given Robot's TokenTorq rating (i.e. "This is a 
- TokenTorqPotential is always sold at a rate of 3.6 TokenTorq/RoboTorq, because that's what he needs to process the tokens he gets from each robot.
- This directly ties the value of energized tokens to the value of the RoboTorq.
- TokenTorq (get it now?) is the throughput of energized tokens processed by a robot.
- It doesn't matter if I use that 3.6 TokenTorq in one hour or one year, I'll pay 1 RoboTorq for it.
- Torq is the extra value created by the robot while processing TokenTorq.
	- `Torq = TokenTorqOut/TokenTorqIn`
 	- and, by convenvtion, `Torq = RoboTorqOut/RoboTorqIn`

# The Equation of AI-Value Exchange

So, `RoboTorqOut/RoboTorqIn = TokenTorqOut/TokenTorqIn`

And: `RoboTorqOut * TokenTorqIn = TokenTorqOut * RoboTorqIn`

This is the differential equation that governs the entire RoboTorq Economy. It can be reformulated to:

And it is expanded to:

And: `RoboTorqOut * TokensIn * EnergyIn = TokensOut * EnergyOut * RoboTorqIn`

And: `RoboTorqOut / (TokensOut * EnergyOut)  = RoboTorqIn / (TokensIn * EnergyIn)`

And: `RoboTorqOut = (TokensOut * EnergyOut * RoboTorqIn) / (TokensIn * EnergyIn)`
- This is the Formula for calculating RoboTorqOut from base values.

# How to Apply The Equation of AI-Value Exchange

Whenever Robot.is_producing = True, the company to which the robot is commissioned is charged 1/3.6 RoboTorq for every TokenTorq processed. Even if it's just standing there. So you can bet that Enterprises are careful about when those flags are True.

Different robots have different TokenTorkPotential
- essentially processing power, but measured in something more useful than Hertz = bits / second
- A 2 TTP Robot can't deliver any more than 2 TokenTork per hour, and would cost 2/3.6 RoboTorq to run for those two hours.
- gives the Enterprise wiggle room on timeline, supply chain disruptions, final price, etc
- gives Daneel wiggle room on scheduling and robot allocation, allowing for load rebalancing
- different robots also have different work history and skill levels. They are not directly transferable
- Though robots can learn from one another faster than learning something by themselves.
- All these factors allow for forecasting production timelines under various conditions.

For example, Oracle Tasks that can tolerate high variance in TokenTorkPotential, having learned to master their learning curves and production timelines, will get better prices on BRLAs for being less selective about which bots they need.

# Complexity of Robotic Labor

But there's more to determining how a robot creates value than just the throughput of the tokens. It's also about what information it has to crunch.

Let's take a second to discuss Oracle.complexity as a variable, which is generally between about: -0.1 <= complexity <= 0.1, where complexity != 0
- for tuning the convergence of the productivity curve.
- This is a time-function of token efficiency: TokensOut/TokensIn/tick
- Negative values of complexity are for Oracles with only one task/item/product
	- where the Torq gains are diminishing as the Oracle is closer to being fulfilled and that item's max torq is fulfilled.
- Positive values of complexity are for Oracles with multiple items,
	- where the Torq gains will increase with each product produced.
 	- max torq defined by the number of items produced * torq/item

And from complexity, we can now discuss another mind-boggling concept: AI entropy, or AIntropy:
- AIntropy = complexity * Tokens * kWH * Robot.util * supply_efficiency * ...
- The AIntropy_curve is how the difficulty of the task shapes the robot's ability to complete it over time.
- All production efficiencies can be multiplied into the token_torq_curve for modeling.

# TokenTorq Curve

token_torq_curve: This learning curve is how quickly a robot gets better at a given task as a function of time.
- This is a measure of productivity in torq / tick = TokensOut/TokensIn/tick
- Think of this like "how good is the robot at crafting the prompts it sends to its AI each tick?"
	- The robot has to learn how to prompt each task efficiently as it's doing it, as the operating conditions are always slightly different for every Oracle.
- At the beginning, the robot is sending bad prompts, but over time, the AI adds more and more value by using tokens more efficiently.
	- This means the robot gets more efficient with time, to a degree, it levels off after the robot gets as good as it can at that task.
- The learning curve of a robot working at 100% utilization is reasonably modeled using a basic Sigmoid Neural Net Activation Time function.

Remember, TokenTorq is the throughput of energized tokens; it'll come into play here.
`token_torq_curve = 1/(1+e^(-ticks * AIntropy))`, where ticks > 0 and 0.0 <= token_learning_curve < 1
- token_torq_curve represents TokenTorq and RoboTorq leaving the {Enterprise, Robot} system.
- Enterprises can either conduct studies to learn what their token_torq_curve might look like, or roll the dice with mathematical modeling.
- They can have a token_torq_curve (production plan) for times of high availability and low
- token_mining_curve is fully integrable and fully differentiable for all values of ticks < 0

Ideal torq_mining_curve: How much Torq is generated as a function of time?
- Is the mathematical integral of token_productivity_curve 
- Unitless: tick/tick = no units
- For a robot working at 100% utilization:
	- `torq_mining_curve = integral(token_torq_curve)
	- `torq_mining_curve = ln(1+e^ticks) + ticks
- As TokenTorq and RoboTorq leave the {Enterprise, Robot} system, the corresponding value is literally integrated into the {Product} system.
- Torq accumulates each tick as TokenTorq is mined into value.
- Eventually, the Oracle will be done, and the final Torq will be calculated and divided by the number of items produced.

The BRLA will wrap up the up Oracle and send the MintRequest to Isaac with a payload of the total Torq accumulated and Oracle.cost. So how will Isaac know how much to mint?

# The Equation of AI-Value Exchange: `RoboTorqOut * TokenTorqIn = TokenTorqOut * RoboTorqIn`

Easy enough. There's one form of the AI-Value Exchange I haven't shown you yet.

RoboTorqOut = TokenTorqOut * RoboTorqIn / TokenTorqIn

Which is really just RoboTorqOut = RoboTorqIn * Torq

Let's say this Oracle.cost = 10 RoboTorq, and the torq caculated was 1.7.

That means the RoboTorq out needs to be 17.

So Isaac will mint 17 - 10 = 7 RoboTorq to account for the markup, and distribute it to bondholders. 

He'll use the 10 RoboTorq to pay for the costs of running the Bond Network, and that will go back into circulation.

The Money Supply is in balance.

This ties the cost of AI consumption to the value created by robotic labor through physical laws.

# Revision Stopping Point: Don't trust info below here

The lazy Enterprise, and maybe smarter, will modify their torq_mining_curve instead of token_mining_curve, because
	- the calculus is atrocious for complex learning curves, with ambiguous payoff, because
	- This form is easy to work with, and by the rules of calculus, you're modifying the learning curve whether you want to or not.
	- but cleans up, at least close enough for practical use. 
	- Let utc = Robot.util * target_torq * AIntropy
	- `Torq_mining_curve = utc * -(ln(1+e^(ticks * utc)) -  utc * ticks)`

But, this is all assuming things go perfectly. Real life is messy.

## Just like today, sometimes Enterprises have to guess how much they can sell something for at market

- torq_gamble: How much value does the company think it can add?
	- unitless scalar
 	- From a standard economics perspective, torq_gamble is the same thing as markup = selling price / production cost
  	- markup is also a unitless scalar, so in order to profit, torq_gamble has to be greater than the entire cost of production:
	- `torq_gamble > (brla_retainer_fee / (Oracle.robot_pool_size * item_count) + Oracle.cost + other production costs + overhead)
	- In robonomics, Isaac will mint exactly expected_selling_price = actual_torq_wielded * Oracle.cost - Oracle.cost
 - But they also have to take into account how many ticks it will take to generate that much raw Torq.
- Robot.util: How efficiently is a robot being utilized?
	- a unitless percentage.
 	- can be calculated/estimated by multiplying the individual efficiencies of the process
  	- `efficiencies = energy_efficiency * supply_efficiency * x_efficiency * y_efficiency ...`
  	- can and will vary from tick to tick.

- actual_torq_wielded: How much of token_torq_available is a robot using as a percentage?
	- can be calculated by multiplying:
 	- token_torq_wielded = token_torq_potential



  - based on Enterprise.torq_gamble. 
	- Intriguing, right? Patience.
- Torq: A unitless scalar achieved by integrating torq_factor, or by multiplying token_torq_consumed * torq_factor (kWh/token * tokens/kWh = no units) 

And picking up [where we left off in TokenTorqTrainingLoop.md](https://github.com/GrokkingGrok/Project-Asimov/blob/MVP/design/src/asimov/flow/TokenTorqTrainingLoop.md):
- Every TorqFountain.tick():
  - The Robot mines its TokenTorq into Torq with varying efficiency (representing production taking place).
    - The more efficiently it mines TokenTorq, the faster Robot.torq increases.
  - Several factors influence TokenTorq --> Torq conversion.
    - The more a robot has done the same task, the more efficiently it mines TokenTorq.
    - The type of task also influences how Torq is mined.
      - Complex tasks draw TokenTorq from Giskard at a higher rate, but mine slowly when production starts, and then produce lots of torq by the end.
      - Simple tasks draw less TokenTorq, but have flatter Torq curves.
    - The lower Giskard.tick_rate, the harder the robot has to work to mine Torq, the more Torq it produces per unit TokenTorq, but less Torq overall.

And then we hammered out the implications of TokenTorq --> Torq conversion: How it affects [Robonomic Expansion, Calvin, and the rest of the system](https://github.com/GrokkingGrok/Project-Asimov/blob/MVP/design/src/RobonomicExpansion.md).

Let's break down the Torq itself.



## Wrench in the Works

In order to calculate Torq during production, we need to know what torq_factor is because as mentioned in the intro: 

	- `Torq = TokenTorqConsumed * torq_factor * Daneel.expected_util`

But we can't know what torq_factor is until we know what torq_gamble is. We'll call it target_torq_factor for now since it's the torq_factor the Enterprise *hopes* to achieve:

`target_torq_factor = (1/(1+e^(-ticks)) - 0.5) / torq_gamble`

Well, you probably don't understand where that just came from. But that's ok, all you need to know for now is that it's a Sigmoid machine learning function, we're using it track time, and that you need torq_gamble to calculate target_torq_factor. 

torq_gamble is a value agreed upon by the Enterprise and BidNet at the time of accepting the Bid for this BRLA.

It represents the value added due to production. It is how the Enterprise makes its wager on the retail price it will sell the item for, hedged by how long they think it will take to make that item or items.

An Enterprise looking to submit their Bid might calculate their torq_gamble as such:

- `torq_gamble = (brla_retainer_fee / (Oracle.robot_pool_size * item_count) + Oracle.cost + other production costs + overhead) * markup 

The Enterprise is using the torq_gamble to bet on the **final realized retail price of the Oracle**. 

But here's how Bidnet will be looking at it.

## Ideal torq_factor Calculation

For reasons not relevant to this discussion, ideal_torq for a given task would be the mathematical integral of torq_factor.

If the general sigmoid form is:  `sigmoid = 1 / (1 + e^-x)`, the general form of the sigmoid integral is: `ln(1*e^(x)) + C`

Adapting that to our form, we get: 

	- `ideal_torq = (ln(1 + e^(ticks)) - .5* ticks - ln2) * torq_gamble +- fudge_factor`

If you solve the integral for how much continuous time it will take for actual_torq_mined to equal torq_gamble, you'll arrive at the ideal_tick_count. That is how quickly Giskard will expect this Oracle type to be produced, on average.

This means that Enterprises are not just bidding on how much they'll pay for the job, but also bidding on how long they think it'll take.

If the company takes too long, they'll overtorq. Too short, they'll undertorq. When the company doesn't have the sale planned in advance, it's wise to mass-produce many items under one Oracle, spreading the risk of over or under torqing across many sales.

Now that we have torq_factor and torq_gamble, we can calculate torq_mined... Once we have a formula for it, at least.



So that's how we calculate Torq. 

Now I know what you might thinking: "But, that means that companies get to ask for how much money they want to be created!" Well, yeah.

And what exactly do you think happens when a business (or you) takes out a loan now?

## But why wouldn't Enterprises just bid for one torq_gamble/timeline, and price for another?

Of course! I hadn't thought of that... Except, come to think of it, what exactly would they gain from such a thing, and how exactly would they do it?

While we haven't quite got there yet, the cost of a BRLA isn't a function of the torq_factor. Sure, it's considered, but it's more of a negotiating point than a function.

And think about what it *really* means... Like we discussed, the torq_factor is going to largely determine how much actual RoboTorq is minted.

**This is the money that the Enterprise's customers need minted for there to be enough RoboTorq to go around, without disturbing the overall money supply.**

Really, we should be more worried about companies bidding high and pricing low so that there is more RoboTorq to chase their goods, making it easier to sell. If Isaac undermints, there will be too few RoboTorq to chase the Enterprise's goods.

So they're not going to be unduly penalized in terms of the cost of a given BRLA. At least, not during that BRLA. But the system will be keeping track.

If an Enterprise is either bad at estimating torq_factor, or they are insistent on trying to game their torq_factor in some way, they'll face much stiffer negotiating tactics at BidNet, and their RoboFund Funnels will alert bondholders. Repeated infractions could result in being kicked off RoboFund, being required to rely on more expensive financing from TorqVaults.

So it's that Enterprise's ability to scheme against a network of AI financial overlords. Should be interesting.

What would be most interesting is if they're both meta-aware of their Nash equilibrium and prisoner's dilemma: Realize that they're making a co-wager on the success of this project, and cooperate to achieve a mutually better outcome.

## Tying Torq into... Quantum Game Theory?

Interestingly, the state Enterprise and Bidnet (and by extension, the customer who buys the product) could be modeled using set superpositioning, like those used in quantum computing algorithms. I wonder where that might lead?

Some wild places. That's where. Metaphorically, when looking at the system from the outside, torq_gamble "entangles" the two. How?

Well, it's impossible to know what the price of the item is going to be until the sale is made. So, like a qubit, measuring the probability cloud collapses the wave function.

This leads to the ability for BidNet to ask Calvin to run Game Theory forecasts from past data when negotiating BRLAs.















