# The Derivation of The RoboTorq from Physical Units

Imagine you had a thermodynamically perfect 1 kW Humanoid Robot. They don't exist and never will. But assume you have one for now. 

What would be the physical value of that ideal Robot's ideal task for 1 hour?

`1 RoboTorq / 1 RoboHour = 1 token * 1kW`, 
- because one thermodynamically perfect 1 kW Robot working for 1 hour processes 1 token with 1 Joule of energy every 1 second for 1 hour, and by definition would earn 1 RoboTorq.

`1 RoboTorq = 1 token * 1KW * 1 RoboHour`, 
- from combining kW and hour to kWh.

`1 kW * 1 RoboHour = 3.6 million RoboJoules`, 
- because RoboJoules is the robotic equivalent of "manpower."
- not a real unit. It only provides context for how the energy is being used, like the word manpower.
- Real unit is Joules = energy, Robojoules = roboticized energy

`1 RoboTorq = 1 token * 3.6 million RoboJoules`, 

`1 micro TokenTorq = 1 token * 1 RoboJoule` 
- The TokenTorq is a novel unit definition: the AI/Robotic equivalent of physical torque.
- Not metaphorical. 
- It is how the information in a token is leveraged into value by roboticized energy.
- This is not unprecedented. Standard torque has the same physical unit as Joules (Newtons * meters), but is consensually agreed upon to represent a different concept.

`1 RoboTorq = 3.6 TokenTorq = 3.6 (token * kWh)`
- This is the value basis for the RoboTorq. It will never change so long as the laws of physics don't.

Likewise, `1 TokenTorq = 1/3.6 RoboTorq = 0.277778 RoboTorq`

That is the natural derivation of the value of 1 RoboTorq: 
- The value produced by 1 "thermodynamically perfect Robot" processing 1 token with 1 Joule of energy every 1 second for 1 hour.

In practice, no bot will ever achieve that feat, and it wouldn't be handy because it's not that much work.

But a perfect Newton * Meter is impossible to achieve too. Kelvins are based on a temperature that's impossible to achieve! We still measure work in Joules and measure temperature in Kelvin.

A commodity like the Gold Standard doesn't technically back the RoboTorq, though we can treat it similarly. 

The RoboTorq is based on the laws of physics themselves and backed by the value produced by robotic labor. While the subjective value may change over time, the physical units may not.

And this is the design doc where I'll prove it to you. Get ready for a whopper.

# The TorqMining Loop

The Torq Mining Flow Loop is where production happens and value is created.

But how much value is created? And we have to tie in the value being added not just by the robot, but by the AI driving the robot!

By the end of this document, you'll discover the direct links between system AI energy consumption and token throughput, aka capacity, how much of that capacity goes to a given Robot, how much of it the robot actually uses, the exact amount of Torq generated by that production, how that Torq scales to market value, and when exactly that value gets transferred to Isaac for minting.

Torq Theory is the direct mathematical tie between AI tokens and minting, calculus and all, that makes Robonomics a revolutionary theory of economics.

## Let's start out with our definitions

TokenTorqPotential: A given Robot's TokenTorq rating, per hour implied (i.e. "This is a 2 TTP bot)
- TokenTorqPotential is always sold at a rate of 3.6 TokenTorq/RoboTorq
- This directly ties the value of energized tokens to the value of the RoboTorq.
- TokenTorq (get it now?) is the throughput of energized tokens processed by a robot.
- It doesn't matter if I use that 3.6 TokenTorq in one hour or one year, I'll pay 1 RoboTorq for it.
- Torq is the scalar representation of extra value created by the robot while processing TokenTorq.
	- `Torq = TokenTorqOut/TokenTorqIn`
 	- and, by convention, `Torq = RoboTorqOut/RoboTorqIn`
	- and, by convention, `Torq = TokensOut/TokensIn` 

# The Equation of AI-Value Exchange: `RoboTorqOut/RoboTorqIn = TokenTorqOut/TokenTorqIn`

So, `RoboTorqOut/RoboTorqIn = TokenTorqOut/TokenTorqIn`

And: `RoboTorqOut * TokenTorqIn = TokenTorqOut * RoboTorqIn`

This is the differential equation that governs the entire RoboTorq Economy. It can be reformulated to:

`RoboTorqOut = TokenTorqOut * RoboTorqIn / TokenTorqIn`

`RoboTorqOut = Torq *  RoboTorqIn`

And it is expanded to:

And: `RoboTorqOut * TokensIn * EnergyIn = TokensOut * EnergyOut * RoboTorqIn`

And: `RoboTorqOut / (TokensOut * EnergyOut)  = RoboTorqIn / (TokensIn * EnergyIn)`

And: `RoboTorqOut = (TokensOut * EnergyOut * RoboTorqIn) / (TokensIn * EnergyIn)`
- This is the Formula for calculating RoboTorqOut from base values.

# How to Apply The Equation of AI-Value Exchange

Whenever Robot.is_producing = True, the company to which the robot is commissioned is charged 1/3.6 RoboTorq for every TokenTorq processed. Even if it's just standing there. So you can bet that Enterprises are careful about when those flags are True.

While Robot.is_producing,
- TokensIn come from Robot's sensors and the program form the task at hand and go to the Robot's neural net.
- TokensOut come from the Robot's neural net and go to the robot's sensors.
- EnergyIn comes from the Robot's battery, and 
- EnergyOut goes out of the system through heat, kinetic energy, etc.
- TokenTorqIn is Robot.token_tork_potential
- TokenTorkOut is a previously agreed upon value: Torq_gamble * Robot.token_tork_potential
- RoboTorqIn is drawn at a maximum rate of 1/3.6 * Robot.token_tork_potential
- RoboTorqOut is achieved by multiplying the RoboTorqIn * torq_gamble.

I'll explain torq_gamble, in the next section. For now, just accept that it's a wager of how much Torq will be generated.

From RoboTorqOut - RoboTorqIn, it's easy to discover how much Isaac needs to mint:
MintingNeeded = RoboTorqOut - RoboTorqIn = RoboTorqIn * torq_gamble - RoboTorqIn 

MintingNeeded = RoboTorqIn * (torq_gamble - 1)

MintingNeeded = 1/3.6 * Robot.token_tork_potential * (torq_gamble - 1)

Keep in mind, this is all for the imaginary ideal robot.

# What exactly is this torq_gamble?

Torq_gamble and markup are two sides of the same coin.

At a bare minimum, if I hope to make a profit, I must make:
`RoboTorqOut > (brla_retainer_fee + RoboTorqIn + other production costs + overhead) 

My torq_gamble is what I bet I can sell the item for, covering my production cost and allowing profit. But here's the thing: Isaac will mint dough once the work happens. The Bond Network is making the exact same bet as me.
`torq_gamble * RoboTorqIn = (brla_retainer_fee + RoboTorqIn + other production costs + overhead) * markup

So once I know the TTP of my robot, I can
- multiply 1/3.6 * TTP to get RoboTorqIn
- multiply Torq_gamble * RoboTorqIn to get RoboTorqOut
- multiply Torq_gamble * TTP to get TokenTorkOut

# So How can I make sure I don't I lose on my torq_gamble?

That's a great question. For starters, I'll need to rate-limit my TokenTorqOut = Robot.token_tork_potential

Different robots have different TokenTorkPotential
- essentially processing power, but measured in something more useful than Hertz = bits / second
- A 2 TTP Robot can't consume any more than 2 TokenTorq per hour, and would cost no more than 2/3.6 RoboTorq to run for that hour
- A 2 TTP Robot can operate at less than 2 TokenTorq per hour, and cost decreases accordingly.
- The TTP ratings of a BRLAs bot pool is secured by the BRLA terms, and ultimately by the brla_retainer_fee.
- Bots with higher TTP ratings can handle more complex jobs more quickly.
- So if I plan for a final torq of 2 TTP/hr, my bot's TTP rating better be way higher to land at 2 after all the efficiency drops, as you'll see soon.

This wiggle room is necessary.
- gives the Enterprise wiggle room on timeline, supply chain disruptions, final price, etc
- gives Daneel wiggle room on scheduling and robot allocation, allowing for load rebalancing
- Different robots also have different work histories and skill levels. They are not directly transferable
- Robots can learn from one another faster than learning something by themselves.
- All these factors allow for forecasting production timelines under various conditions.

For example, Enterprises that can tolerate high variance in TokenTorkPotential or number bots, having learned to master their TokenTorq Curves and production timelines, will get better prices on BRLAs for being less selective about which bots they need, how many they need, and when they need them. If I need 100 bots exactly 2.5 TTP, that's a tougher order than taking whatever Daneel's got to spare without reblancing.

# Complexity of Robotic Labor

There's more to determining how a robot creates value than just the throughput of the tokens. It's also about what information it has to crunch.

And like I said, we're not dealing with anywhere near ideal robots. 

Let's take a second to discuss Oracle.complexity as a variable, which is theoretically, any real number where complexity != 0
- complexity is used for tuning the timeline and convergence value of the productivity curve.
- This is a time-function of token efficiency: TokensOut/TokensIn/tick = Torq/tick
- Negative values of complexity are for Oracles with only one task/item/product,
	- and hence Torq production approaches the value of the item as productivity approaches zero.
	- Torq gains are diminishing as the Oracle is closer to being fulfilled and that item's max torq is fulfilled.
	- This prevents overminting on single item tasks.
- Positive values of complexity are for Oracles with multiple items,
	- where the Torq gains will increase with each product produced.
 	- max torq = torq * items produced.

And from complexity, we can now discuss another mind-boggling concept: AI entropy, or AIntropy:
- AIntropy = complexity * TTP * Robot.util * supply_efficiency * equipment_utilization * ...
- The AIntropy_curve is how the difficulty of the task shapes the robot's ability to complete it over time.
- All production efficiencies can be multiplied into the token_torq_curve for modeling, such as supply_efficiency, equipment_utilization, etc.
- This means my bot's effective TTP is much lower due to production inefficiencies.
- This lowers TokensOut/hour, which lowers TokenTorqOut/hour, which lowers RoboTorqOut/hour.
- This means more hours have to be worked than the ideal bot.

This is how we account for the fact that we don't have a perfect robot, and never will. We will have to pay more than 1 RoboTorq to create the same amount of value as that ideal robot, but we can still use that robot's math to understand the problem. And that's what we'll do because the calculus is atrocious once you start tuning it.

And we still purchase TokenTorq on the basis of 1 RoboTorq = 3.6 TokenTorq, because that is the physical unit of RoboTorq.

Each inefficiency added takes us further away from that "perfect" robot and closer to reality, while the markup is the expected value creation that the Enterprise and the Bond network are both betting the product can be sold for (aka the torq_gamble).

It's getting harder to win this wager, right?

Don't worry, there are tools to help.

# TokenTorq Curve

token_torq_curve: This learning curve is how quickly a robot gets better at a given task as a function of time.
- This is a measure of the rate at which torq is being generated at time tick.
- Think of this like "how good is the robot at crafting the prompts it sends to its AI each tick?"
	- The robot has to learn how to prompt each task efficiently as it's doing it, as the operating conditions are always slightly different for every Oracle.
- At the beginning, the robot is sending bad prompts, but over time, the AI adds more and more value by using tokens more efficiently.
	- This means the robot gets more efficient with time, to a degree, it levels off after the robot gets as good as it can at that task.
- The learning curve as a function of time of a robot's neural net is reasonably modeled using a basic Sigmoid Neural Net Activation Time function.

Remember, TokenTorq is the throughput of energized tokens; it'll come into play here.
`token_torq_curve = 1/(1+e^(-ticks * AIntropy)) * torq_gamble`, where ticks > 0 and 0.0 < token_torq_curve < 1
- token_torq_curve represents TokenTorq and RoboTorq leaving the {Enterprise, Robot} system.
- Enterprises can either conduct studies to learn what their token_torq_curve might look like, or roll the dice with mathematical modeling.
- They can have a token_torq_curve (production plan) for times of high availability and low
- token_mining_curve is fully integrable and fully differentiable for all values of ticks < 0

# Sample Token Torq Curve

A real TokenTokeCurve would look something like this: 
- `token_torq_curve = 1/(1+e^(-ticks * AIntropy)) * torq_gamble - 0.5`
- AIntropy and torq gamble are as we discussed earlier.
- torq gamble is the maximum amplitude of TokenTorq
- AIntropy ramps up/down the time it takes to converge with TTP, and flips the convergence to zero if negative.

Enterprises can use TokenTorq Curves to estimate production timelines by anticipating when their robots will reach full productivity and begin churning out value.

# Mining TokenTorq into Torq

Mathematically, you can take the integral of the TokenTorq Curve and calculate the torq that builds up each step.

Ideal torq_mining_curve: How much Torq is generated as a function of time?
- Is the mathematical integral of token_productivity_curve 
- Unit produced is Torq accumulating at time tick increases
- For a robot working at 100% utilization:
	- `torq_mining_curve = integral(token_torq_curve)
	- `torq_mining_curve = (ln(AIntropy(1+e^(ticks * AIntropy))) - ticks * AIntropy)
- As TokenTorq and RoboTorq leave the {Enterprise, Robot} system, the corresponding value is literally integrated into the {Product} system.
- Torq accumulates each tick as TokenTorq is mined into value.
- Eventually, the Oracle will be done, and the final Torq will be calculated and divided by the number of items produced.

  Programmatically, this will initially be calculated using Reimann Sums: AIntropy * torq_mining_curve(tick).

The BRLA will wrap up the Oracle and send the MintRequest to Isaac with a payload of the total Torq accumulated and Oracle.cost. So how will Isaac know how much to mint?

# A sample problem.

Easy enough. Let's say we're working with a 5 TTP bot, a torq_gamble of 3, and production inefficiencies result in an AIntropy =.5 * TTP = 2.5.

Even though the robot will only provide 2.5 TTP per tick, the robot will be paid 5/3.6 = 1.389 RoboTorq per tick for 100 ticks.

MintingNeeded = 1/3.6 * Robot.token_tork_potential * (torq_gamble - 1)

MintingNeeded = 5/3.6 * 100 (3 - 1) = 277.778 RoboTorq

This means the Enterprise had bet that they can sell this item for 138.889 + 277.778 = 416.667 Robotorq.

So Isaac will mint 277.778 RoboTorq to cover the markup, then distribute them to bondholders. 

He'll use the 138.889 RoboTorq to pay for the costs of running the Bond Network, and that will go back into circulation, along with brla_retainer_fee.

The Money Supply is in balance.

This ties the cost of AI consumption to the value created by robotic labor through physical laws.

# Revision Stopping Point: Don't trust info below here

The lazy Enterprise, and maybe smarter, will modify their torq_mining_curve instead of token_mining_curve, because
	- the calculus is atrocious for complex learning curves, with ambiguous payoff, because
	- This form is easy to work with, and by the rules of calculus, you're modifying the learning curve whether you want to or not.
	- but cleans up, at least close enough for practical use. 
	- Let utc = Robot.util * target_torq * AIntropy
	- `Torq_mining_curve = utc * -(ln(1+e^(ticks * utc)) -  utc * ticks)`

But, this is all assuming things go perfectly. Real life is messy.

## Just like today, sometimes Enterprises have to guess how much they can sell something for at market

- torq_gamble: How much value does the company think it can add?
	- unitless scalar
 	- From a standard economics perspective, torq_gamble is the same thing as markup = selling price / production cost
  	- markup is also a unitless scalar, so in order to profit, torq_gamble has to be greater than the entire cost of production:
	- `torq_gamble > (brla_retainer_fee / (Oracle.robot_pool_size * item_count) + Oracle.cost + other production costs + overhead)
	- In robonomics, Isaac will mint exactly expected_selling_price = actual_torq_wielded * Oracle.cost - Oracle.cost
 - But they also have to take into account how many ticks it will take to generate that much raw Torq.
- Robot.util: How efficiently is a robot being utilized?
	- a unitless percentage.
 	- can be calculated/estimated by multiplying the individual efficiencies of the process
  	- `efficiencies = energy_efficiency * supply_efficiency * x_efficiency * y_efficiency ...`
  	- can and will vary from tick to tick.

- actual_torq_wielded: How much of token_torq_available is a robot using as a percentage?
	- can be calculated by multiplying:
 	- token_torq_wielded = token_torq_potential



  - based on Enterprise.torq_gamble. 
	- Intriguing, right? Patience.
- Torq: A unitless scalar achieved by integrating torq_factor, or by multiplying token_torq_consumed * torq_factor (kWh/token * tokens/kWh = no units) 

And picking up [where we left off in TokenTorqTrainingLoop.md](https://github.com/GrokkingGrok/Project-Asimov/blob/MVP/design/src/asimov/flow/TokenTorqTrainingLoop.md):
- Every TorqFountain.tick():
  - The Robot mines its TokenTorq into Torq with varying efficiency (representing production taking place).
    - The more efficiently it mines TokenTorq, the faster Robot.torq increases.
  - Several factors influence TokenTorq --> Torq conversion.
    - The more a robot has done the same task, the more efficiently it mines TokenTorq.
    - The type of task also influences how Torq is mined.
      - Complex tasks draw TokenTorq from Giskard at a higher rate, but mine slowly when production starts, and then produce lots of torq by the end.
      - Simple tasks draw less TokenTorq, but have flatter Torq curves.
    - The lower Giskard.tick_rate, the harder the robot has to work to mine Torq, the more Torq it produces per unit TokenTorq, but less Torq overall.

And then we hammered out the implications of TokenTorq --> Torq conversion: How it affects [Robonomic Expansion, Calvin, and the rest of the system](https://github.com/GrokkingGrok/Project-Asimov/blob/MVP/design/src/RobonomicExpansion.md).

Let's break down the Torq itself.



## Wrench in the Works

In order to calculate Torq during production, we need to know what torq_factor is because as mentioned in the intro: 

	- `Torq = TokenTorqConsumed * torq_factor * Daneel.expected_util`

But we can't know what torq_factor is until we know what torq_gamble is. We'll call it target_torq_factor for now since it's the torq_factor the Enterprise *hopes* to achieve:

`target_torq_factor = (1/(1+e^(-ticks)) - 0.5) / torq_gamble`

Well, you probably don't understand where that just came from. But that's ok, all you need to know for now is that it's a Sigmoid machine learning function, we're using it track time, and that you need torq_gamble to calculate target_torq_factor. 

torq_gamble is a value agreed upon by the Enterprise and BidNet at the time of accepting the Bid for this BRLA.

It represents the value added due to production. It is how the Enterprise makes its wager on the retail price it will sell the item for, hedged by how long they think it will take to make that item or items.

An Enterprise looking to submit their Bid might calculate their torq_gamble as such:

- `torq_gamble = (brla_retainer_fee / (Oracle.robot_pool_size * item_count) + Oracle.cost + other production costs + overhead) * markup 

The Enterprise is using the torq_gamble to bet on the **final realized retail price of the Oracle**. 

But here's how Bidnet will be looking at it.

## Ideal torq_factor Calculation

For reasons not relevant to this discussion, ideal_torq for a given task would be the mathematical integral of torq_factor.

If the general sigmoid form is:  `sigmoid = 1 / (1 + e^-x)`, the general form of the sigmoid integral is: `ln(1*e^(x)) + C`

Adapting that to our form, we get: 

	- `ideal_torq = (ln(1 + e^(ticks)) - .5* ticks - ln2) * torq_gamble +- fudge_factor`

If you solve the integral for how much continuous time it will take for actual_torq_mined to equal torq_gamble, you'll arrive at the ideal_tick_count. That is how quickly Giskard will expect this Oracle type to be produced, on average.

This means that Enterprises are not just bidding on how much they'll pay for the job, but also bidding on how long they think it'll take.

If the company takes too long, they'll overtorq. Too short, they'll undertorq. When the company doesn't have the sale planned in advance, it's wise to mass-produce many items under one Oracle, spreading the risk of over or under torqing across many sales.

Now that we have torq_factor and torq_gamble, we can calculate torq_mined... Once we have a formula for it, at least.



So that's how we calculate Torq. 

Now I know what you might thinking: "But, that means that companies get to ask for how much money they want to be created!" Well, yeah.

And what exactly do you think happens when a business (or you) takes out a loan now?

## But why wouldn't Enterprises just bid for one torq_gamble/timeline, and price for another?

Of course! I hadn't thought of that... Except, come to think of it, what exactly would they gain from such a thing, and how exactly would they do it?

While we haven't quite got there yet, the cost of a BRLA isn't a function of the torq_factor. Sure, it's considered, but it's more of a negotiating point than a function.

And think about what it *really* means... Like we discussed, the torq_factor is going to largely determine how much actual RoboTorq is minted.

**This is the money that the Enterprise's customers need minted for there to be enough RoboTorq to go around, without disturbing the overall money supply.**

Really, we should be more worried about companies bidding high and pricing low so that there is more RoboTorq to chase their goods, making it easier to sell. If Isaac undermints, there will be too few RoboTorq to chase the Enterprise's goods.

So they're not going to be unduly penalized in terms of the cost of a given BRLA. At least, not during that BRLA. But the system will be keeping track.

If an Enterprise is either bad at estimating torq_factor, or they are insistent on trying to game their torq_factor in some way, they'll face much stiffer negotiating tactics at BidNet, and their RoboFund Funnels will alert bondholders. Repeated infractions could result in being kicked off RoboFund, being required to rely on more expensive financing from TorqVaults.

So it's that Enterprise's ability to scheme against a network of AI financial overlords. Should be interesting.

What would be most interesting is if they're both meta-aware of their Nash equilibrium and prisoner's dilemma: Realize that they're making a co-wager on the success of this project, and cooperate to achieve a mutually better outcome.

## Tying Torq into... Quantum Game Theory?

Interestingly, the state Enterprise and Bidnet (and by extension, the customer who buys the product) could be modeled using set superpositioning, like those used in quantum computing algorithms. I wonder where that might lead?

Some wild places. That's where. Metaphorically, when looking at the system from the outside, torq_gamble "entangles" the two. How?

Well, it's impossible to know what the price of the item is going to be until the sale is made. So, like a qubit, measuring the probability cloud collapses the wave function.

This leads to the ability for BidNet to ask Calvin to run Game Theory forecasts from past data when negotiating BRLAs.















